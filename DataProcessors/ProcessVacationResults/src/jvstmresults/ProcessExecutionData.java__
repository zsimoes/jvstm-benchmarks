package jvstmresults;
import java.io.File;
import java.io.FileFilter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

public class ProcessExecutionData
{
	
	private JVSTMLog jvstmLog;
	
	public ProcessExecutionData(JVSTMLog jvstmLog) {
		this.jvstmLog = jvstmLog;
	}

	protected static String nl = System.getProperty("line.separator");
	
	protected static final String rootFolderName = ".";
	protected static final String gnuplotCode = "# This file was generated by ProcessConvergenceData.java."
			+ nl + "reset" + nl + "set terminal pdfcairo" + nl + "unset for [i=1:8] label i"
			+ nl + "set title \"jvstm execution time comparison\"" + nl
			+ "set xlabel \"configuration\"" + nl + "set bmargin 6" + nl + "set offset .05, .05"
			+ nl

			+ "set style line 1 lt -1 lc rgb \"black\" pi -1 pt 4 ps 0.4 lw 2" + nl
			+ "set style line 2 lt -1 lc rgb \"black\" pi -1 pt 5 ps 0.4 lw 2" + nl
			+ "set style line 3 lt -1 lc rgb \"black\" pi -1 pt 6 ps 0.4 lw 2" + nl
			+ "set style line 4 lt -1 lc rgb \"black\" pi -1 pt 7 ps 0.4 lw 2" + nl
			+ "set style line 5 lt -1 lc rgb \"black\" pi -1 pt 8 ps 0.4 lw 2" + nl
			+ "set style line 6 lt -1 lc rgb \"black\" pi -1 pt 9 ps 0.4 lw 2" + nl + nl
			+ "# The following sections generate plots for the result file data:" + nl + nl;

	protected String getGPOutputString(String targetFile)
	{
		return "set output \"" + targetFile + "\"" + nl;
	}

	protected static final String startPlot = "plot ";

	protected String getPlotLine(ResultFile resultFile, int linestyle, boolean endPlot)
	{
		String result = " '" + resultFile.file.getName() + "' " + "using 2:xticlabels(1) with linespoints ls "
				+ +linestyle + " title '" + resultFile.policy + "-" + resultFile.contention + "' "
				+ (endPlot ? "" : ", \\") + nl;
		return result;
	}

	protected String getPlotLine(ResultFile resultFile, String subFolderName, int linestyle, boolean endPlot)
	{
		String result = " '" + subFolderName + File.separator + resultFile.file.getName() + "' "
				+ "using 2:xticlabels(1) with linespoints ls " + linestyle + " title '" + resultFile.policy + "-"
				+ resultFile.contention + "' " + (endPlot ? "" : ", \\") + nl;
		return result;
	}

	public void process() throws IOException
	{
		StringBuilder gnuplotBuilder = new StringBuilder();
		List<JvstmResultFolder> policyFolders = processFolders();

		gnuplotBuilder.append(gnuplotCode);
		for (JvstmResultFolder jvstmFolder : policyFolders)
		{
			gnuplotBuilder.append("#JVSTM type: " + jvstmFolder.jvstmType + nl);
			gnuplotBuilder.append(getGPOutputString("execution-" + jvstmFolder.jvstmType + ".pdf") + nl);

			for (String contentionType : jvstmFolder.getContentionTypes())
			{
				gnuplotBuilder.append(startPlot);
				List<ResultFile> results = jvstmFolder.getResultsForContention(contentionType);
				for (int i = 0; i < results.size(); i++)
				{
					gnuplotBuilder.append(getPlotLine(results.get(i), jvstmFolder.relativeFolder, i + 1,
							i == (results.size() - 1)));
				}
				gnuplotBuilder.append(nl);
			}
			gnuplotBuilder.append(nl);
			gnuplotBuilder.append(nl);
		}
		gnuplotBuilder.append(nl);

		String executionGPResult = "execution.gp";
		File gnuplot = new File(executionGPResult);
		Writer w = new FileWriter(gnuplot, false);
		w.write(gnuplotBuilder.toString());
		w.close();

		System.err.println("Done - generated file " + "execution.gp");
	}

	FileFilter vacationExecutionFilter = new FileFilter()
	{
		@Override
		public boolean accept(File pathname)
		{
			String[] parts = pathname.getName().split("\\.");
			String ext = parts[parts.length - 1];
			return !pathname.isDirectory() && ext.startsWith("surfacedata");
		}
	};
	FileFilter jvstmDirectoryFilter = new FileFilter()
	{
		@Override
		public boolean accept(File pathname)
		{
			return pathname.isDirectory() && pathname.getName().contains("jvstm");
		}
	};

	class JvstmResultFolder
	{
		public String relativeFolder;
		public String jvstmType;
		public List<ResultFile> resultFiles;
		protected Set<String> contentionTypes;

		public JvstmResultFolder(String relativeFolder, String jvstmType)
		{
			super();
			this.resultFiles = new ArrayList<ResultFile>();
			this.contentionTypes = new TreeSet<String>();
			this.relativeFolder = relativeFolder;
			this.jvstmType = jvstmType;
		}

		public Set<String> getContentionTypes()
		{
			return contentionTypes;
		}

		public void add(ResultFile resultFile)
		{
			contentionTypes.add(resultFile.contention);
			resultFiles.add(resultFile);
		}

		public List<ResultFile> getResultsForContention(String contention)
		{
			List<ResultFile> result = new ArrayList<ResultFile>();
			for (ResultFile file : this.resultFiles)
			{
				if (file.contention.equals(contention))
				{
					result.add(file);
				}
			}
			return result;
		}

	}

	class ResultFile
	{
		public File file;
		public String policy;
		public String contention;

		public ResultFile(File file, String contention, String policy)
		{
			super();
			this.file = file;
			this.policy = policy;
			this.contention = contention;
		}

		public ResultFile(File file)
		{
			super();
			try
			{
				String filename = file.getName();
				String policy = filename.substring(0, filename.indexOf('-'));
				String cont = filename.substring(filename.indexOf('-') + 1, filename.indexOf('.'));
				this.file = file;
				this.policy = policy;
				this.contention = cont;
			} catch (ArrayIndexOutOfBoundsException e)
			{
				throw new RuntimeException("invalid file name/format: " + file.getAbsolutePath());
			} catch (NullPointerException e)
			{
				throw new RuntimeException("invalid file name/format: " + file.getAbsolutePath());
			}
		}
	}

	public List<JvstmResultFolder> processFolders() throws IOException
	{
		File root = new File(".");
		return walk(root.getAbsolutePath());
	}

	protected List<JvstmResultFolder> walk(String path)
	{

		List<JvstmResultFolder> result = new ArrayList<JvstmResultFolder>();
		File root = new File(path);
		File[] list = root.listFiles(jvstmDirectoryFilter);

		if (list == null)
			return result;

		for (File f : list)
		{
			result.add(parseDirectory(f));
		}
		return result;
	}

	public JvstmResultFolder parseDirectory(File directory)
	{
		if (!jvstmDirectoryFilter.accept(directory))
		{
			throw new RuntimeException("parseDirectory: Not a directory, or not a jvstm result directory.");
		}

		JvstmResultFolder result = new JvstmResultFolder(directory.getName(), directory.getName());

		File[] files = directory.listFiles(vacationExecutionFilter);
		for (File dataFile : files)
		{
			result.add(new ResultFile(dataFile));
		}
		return result;
	}
}
